<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <title>智能排放管控驾驶舱</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/modern-css-reset@1.4.0/dist/reset.min.css"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-start: #f5f7ff;
        --bg-end: #f0f9ff;
        --text-strong: #0f172a;
        --text-muted: #64748b;
        --primary: #2563eb;
        --accent: #7c3aed;
        --card-bg: rgba(255, 255, 255, 0.92);
        --border: rgba(148, 163, 184, 0.25);
        --radius-lg: 22px;
        --radius-md: 16px;
        --shadow-soft: 0 32px 60px rgba(15, 23, 42, 0.12);
        --shadow-light: 0 18px 38px rgba(37, 99, 235, 0.18);
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      body {
        font-family: "Manrope", "Segoe UI", Arial, sans-serif;
        color: var(--text-strong);
        line-height: 1.65;
        min-height: 100vh;
        position: relative;
        background: var(--bg-end);
        -webkit-font-smoothing: antialiased;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        z-index: -2;
        background:
          radial-gradient(circle at 12% 18%, rgba(124, 58, 237, 0.16), transparent 55%),
          radial-gradient(circle at 82% 12%, rgba(37, 99, 235, 0.15), transparent 60%),
          linear-gradient(180deg, var(--bg-start) 0%, var(--bg-end) 100%);
      }

      body::after {
        content: "";
        position: fixed;
        inset: 0;
        z-index: -1;
        background:
          radial-gradient(circle at 50% 92%, rgba(15, 23, 42, 0.08), transparent 60%);
        opacity: 0.9;
      }

      .container {
        max-width: 1180px;
        margin: 48px auto 72px;
        padding: 0 28px 80px;
        display: flex;
        flex-direction: column;
        gap: 28px;
      }

      header {
        text-align: center;
        display: grid;
        gap: 18px;
        margin-bottom: 10px;
      }

      header h1 {
        font-size: clamp(2.2rem, 2.4vw, 2.9rem);
        font-weight: 700;
        letter-spacing: 0.12em;
        text-transform: uppercase;
      }

      header p {
        font-size: 1.05rem;
        color: var(--text-muted);
        max-width: 820px;
        justify-self: center;
      }

      .section-lead {
        color: var(--text-muted);
        margin-bottom: 18px;
        font-size: 0.98rem;
      }

      .panel {
        background: var(--card-bg);
        border-radius: var(--radius-lg);
        border: 1px solid var(--border);
        box-shadow: var(--shadow-soft);
        padding: 32px;
        backdrop-filter: blur(18px);
        position: relative;
        overflow: hidden;
      }

      .panel::before {
        content: "";
        position: absolute;
        top: -60px;
        right: -80px;
        width: 220px;
        height: 220px;
        background: radial-gradient(
          circle,
          rgba(37, 99, 235, 0.16) 0%,
          rgba(124, 58, 237, 0.05) 55%,
          transparent 80%
        );
        transform: rotate(12deg);
      }

      .panel > *:first-child {
        position: relative;
        z-index: 1;
      }

      .panel h2 {
        font-size: 1.45rem;
        margin-bottom: 14px;
        display: flex;
        align-items: center;
        gap: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        background: rgba(37, 99, 235, 0.12);
        border-radius: 999px;
        padding: 6px 14px;
        font-size: 0.82rem;
        color: var(--primary);
        text-transform: none;
      }

      form {
        display: grid;
        gap: 20px;
      }

      .feature-grid {
        display: grid;
        gap: 14px;
        grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
      }

      .feature-grid label {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 0.88rem;
        color: var(--text-muted);
        padding: 12px 14px;
        border-radius: var(--radius-md);
        border: 1px solid rgba(148, 163, 184, 0.28);
        background: rgba(248, 250, 252, 0.6);
      }

      .feature-grid input {
        padding: 10px 12px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        border-radius: 10px;
        font-size: 1rem;
        transition: border 0.2s ease, box-shadow 0.2s ease;
        color: var(--text-strong);
        background: #fff;
      }

      .feature-grid input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
      }

      .control-row {
        display: flex;
        flex-wrap: wrap;
        gap: 14px;
        align-items: center;
      }

      select,
      button {
        padding: 12px 18px;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.5);
        font-size: 1rem;
        background: #fff;
        color: var(--text-strong);
      }

      button {
        background: linear-gradient(135deg, var(--primary), var(--accent));
        color: #fff;
        border: none;
        cursor: pointer;
        font-weight: 600;
        box-shadow: var(--shadow-light);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 22px 32px rgba(37, 99, 235, 0.22);
      }

      code {
        font-family: "Fira Code", "Consolas", monospace;
        background: rgba(15, 23, 42, 0.06);
        padding: 2px 6px;
        border-radius: 6px;
        font-size: 0.85rem;
      }

      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 0.92rem;
        color: var(--text-muted);
      }

      .toggle input {
        width: 18px;
        height: 18px;
      }

      .result {
        margin-top: 12px;
        font-size: 0.98rem;
        color: var(--text-strong);
      }

      .grid-two {
        display: grid;
        gap: 20px;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }

      .muted {
        color: var(--text-muted);
        font-size: 0.9rem;
      }

      .error {
        color: #dc2626;
        margin-top: 10px;
      }

      .capability-grid,
      .strategy-grid,
      .model-grid {
        display: grid;
        gap: 20px;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }

      .capability-card,
      .strategy-card,
      .model-card {
        padding: 22px;
        border-radius: var(--radius-md);
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: linear-gradient(180deg, rgba(248, 250, 252, 0.92), #ffffff 100%);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7);
      }

      .capability-card h3,
      .strategy-card h3,
      .model-card h3 {
        font-size: 1.1rem;
        margin-bottom: 10px;
      }

      .capability-card p,
      .strategy-card p,
      .model-card p {
        color: var(--text-muted);
        line-height: 1.6;
        margin-bottom: 12px;
      }

      .capability-card ul,
      .model-card ul {
        margin: 0;
        padding-left: 18px;
        color: var(--text-strong);
        line-height: 1.5;
      }

      .strategy-meta {
        color: var(--primary);
        font-size: 0.9rem;
        font-weight: 600;
      }

      .workflow {
        display: grid;
        gap: 18px;
      }

      .workflow-step {
        border-left: 3px solid rgba(37, 99, 235, 0.35);
        padding-left: 16px;
      }

      .workflow-step h3 {
        font-size: 1.05rem;
        margin-bottom: 6px;
      }

      .workflow-step span {
        display: inline-block;
        background: rgba(37, 99, 235, 0.12);
        color: var(--primary);
        font-size: 0.82rem;
        font-weight: 700;
        padding: 4px 12px;
        border-radius: 999px;
        margin-bottom: 6px;
        letter-spacing: 0.08em;
      }

      .workflow-step p {
        color: var(--text-muted);
        line-height: 1.6;
      }

      .stat-grid {
        display: grid;
        gap: 16px;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        margin-bottom: 12px;
      }

      .stat-card {
        background: linear-gradient(
          135deg,
          rgba(37, 99, 235, 0.12),
          rgba(124, 58, 237, 0.08)
        );
        border-radius: var(--radius-md);
        border: 1px solid rgba(37, 99, 235, 0.25);
        padding: 18px 20px;
        display: grid;
        gap: 6px;
      }

      .stat-label {
        font-size: 0.78rem;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.14em;
      }

      .stat-value {
        font-size: 1.8rem;
        font-weight: 700;
        color: var(--text-strong);
      }

      .stat-hint {
        font-size: 0.85rem;
        color: var(--text-muted);
      }

      .data-card {
        background: rgba(255, 255, 255, 0.65);
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: var(--radius-md);
        padding: 18px 20px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7);
      }

      .data-card + .data-card {
        margin-top: 0;
      }

      caption {
        text-align: left;
        margin-bottom: 10px;
        font-weight: 600;
        color: var(--text-strong);
        letter-spacing: 0.04em;
      }

      .data-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.92rem;
      }

      .data-table thead th {
        background: rgba(37, 99, 235, 0.08);
        color: var(--text-strong);
        font-weight: 600;
        padding: 10px 14px;
        text-align: left;
        border-bottom: 1px solid rgba(148, 163, 184, 0.35);
      }

      .data-table tbody td {
        border-bottom: 1px solid rgba(148, 163, 184, 0.18);
        padding: 10px 14px;
      }

      .data-table tbody tr:nth-child(even) {
        background: rgba(15, 23, 42, 0.03);
      }

      .data-table tbody tr:last-child td {
        border-bottom: none;
      }

      .tag-cloud {
        margin-top: 22px;
        display: grid;
        gap: 12px;
      }

      .tag-title {
        font-size: 0.95rem;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--text-muted);
      }

      .tag-list {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .tag {
        display: inline-flex;
        align-items: center;
        padding: 6px 12px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.06);
        color: var(--text-strong);
        font-size: 0.85rem;
        border: 1px solid rgba(15, 23, 42, 0.08);
      }

      .card-title {
        font-size: 0.95rem;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--text-strong);
        margin-bottom: 12px;
      }

      .sub-card {
        background: rgba(255, 255, 255, 0.8);
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: var(--radius-md);
        padding: 16px 18px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7);
        margin-bottom: 16px;
      }

      .card-separator {
        height: 1px;
        margin: 16px 0;
        background: rgba(148, 163, 184, 0.28);
      }

      .highlight-card {
        padding: 20px;
        border-radius: var(--radius-md);
        border: 1px solid rgba(226, 232, 240, 0.7);
        background: linear-gradient(
          120deg,
          rgba(248, 250, 252, 0.85),
          rgba(255, 255, 255, 0.72)
        );
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7);
      }

      .status-pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        border-radius: 999px;
        background: rgba(37, 99, 235, 0.12);
        color: var(--primary);
        font-size: 0.85rem;
        font-weight: 600;
      }

      .result .highlight-card {
        margin-top: 10px;
      }

      @media (max-width: 720px) {
        .container {
          padding: 0 18px 60px;
        }

        .panel {
          padding: 24px;
        }

        header h1 {
          letter-spacing: 0.08em;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>智能排放管控驾驶舱</h1>
        <p>
          一站式洞察数据质量、模型表现、特征影响与优化策略，实时掌握排放风险，先人一步做出高阶决策。
        </p>
      </header>

      <section class="panel" id="capability-panel">
        <h2>
          平台能力全景
          <span class="badge">数据 · 建模 · 优化 · 运维 一体化</span>
        </h2>
        <div class="capability-grid">
          <article class="capability-card">
            <h3>数据智能引擎</h3>
            <p>
              基于 <code>data_preprocessing.py</code> 的自动化流水线，确保不同来源的原始数据在分钟级完成治理。
            </p>
            <ul>
              <li>CSV / SQLite 多源导入与中文字段智能映射。</li>
              <li>缺失值填补、异常值剔除、数值化与标准化全流程。</li>
              <li>构建平方项、比值、对数等领域特征并自动消除共线性。</li>
            </ul>
          </article>
          <article class="capability-card">
            <h3>模型融合引擎</h3>
            <p>
              <code>ModelManager</code> 同时管理五大回归器，并提供多种策略以满足不同业务场景的精度与稳定性需求。
            </p>
            <ul>
              <li>mean / equal / residual / self_adaption / stacking 多策略一键切换。</li>
              <li>输出 R²、MAPE、MAE、RMSE 全量评估指标与不确定性区间。</li>
              <li>支持 SHAP 与 permutation importance 深入解释特征贡献。</li>
            </ul>
          </article>
          <article class="capability-card">
            <h3>优化决策大脑</h3>
            <p>
              <code>optimization.py</code> 与 <code>ExperimentManager</code> 组成的智能实验平台，为排放控制策略提供实时迭代能力。
            </p>
            <ul>
              <li>内置 PSO、贝叶斯、遗传算法多策略对 <code>emission_objective</code> 迭代寻优。</li>
              <li>实验日志、最优参数与目标值完整留痕，便于对比复盘。</li>
              <li>ProcessMonitor 异常触发自动调优，阈值策略可通过 Config 自定义。</li>
            </ul>
          </article>
          <article class="capability-card">
            <h3>工程化运维保障</h3>
            <p>
              自带 API、模型版本化与测试脚本，帮助团队快速落地并持续交付。
            </p>
            <ul>
              <li>Flask 服务暴露 /predict、/metadata 等接口即插即用。</li>
              <li>模型工件通过 Joblib 版本化持久化，方便部署回滚。</li>
              <li><code>main.py</code> 与 <code>tests/</code> 提供离线验证与冒烟测试保障。</li>
            </ul>
          </article>
        </div>
      </section>

      <section class="panel" id="workflow-panel">
        <h2>
          闭环工作流
          <span class="badge">从数据到决策的每一步都可追溯</span>
        </h2>
        <div class="workflow">
          <div class="workflow-step">
            <span>Step 01</span>
            <h3>数据导入与治理</h3>
            <p>
              <code>load_training_frame</code> 自动识别外部数据源，配合清洗、字段映射与缺失值处理，生成高质量原始数据集。
            </p>
          </div>
          <div class="workflow-step">
            <span>Step 02</span>
            <h3>特征构建与筛选</h3>
            <p>
              通过比值、平方、对数等特征工程与共线性消除策略，形成可用于建模的稳健特征矩阵与质量报告。
            </p>
          </div>
          <div class="workflow-step">
            <span>Step 03</span>
            <h3>多模型集成训练</h3>
            <p>
              <code>ModelManager</code> 统一训练随机森林、XGBoost、MLP 等模型，并自动计算集成权重与元学习 Stacking 模型。
            </p>
          </div>
          <div class="workflow-step">
            <span>Step 04</span>
            <h3>智能优化与监控</h3>
            <p>
              ExperimentManager 运行多策略实验，ProcessMonitor 实时监听并触发 PSO / GA / 贝叶斯调优，形成动态阈值控制。
            </p>
          </div>
          <div class="workflow-step">
            <span>Step 05</span>
            <h3>可视化与服务化交付</h3>
            <p>
              Flask API 与本驾驶舱页面提供在线预测、指标监控、特征洞察，帮助业务快速验证与部署减排策略。
            </p>
          </div>
        </div>
      </section>

      <section class="panel" id="strategy-panel">
        <h2>
          集成策略地图
          <span class="badge">自适应融合与单模直推一览</span>
        </h2>
        <p class="section-lead">
          策略描述与权重来自后端实时同步，可帮助快速理解不同组合在当前数据下的决策特点。
        </p>
        <div id="strategy-overview">
          <p class="muted">策略信息加载中…</p>
        </div>
      </section>

      <section class="panel" id="model-panel">
        <h2>
          模型家族能力
          <span class="badge">基础模型优势速览</span>
        </h2>
        <p class="section-lead">
          所有基础模型均由 <code>ModelManager</code> 统一训练与调度，以下亮点帮助快速匹配业务场景。
        </p>
        <div id="model-hub">
          <p class="muted">模型详情加载中…</p>
        </div>
      </section>

      <section class="panel" id="prediction-panel">
        <h2>
          在线预测
          <span class="badge">支持策略组合 &amp; 不确定性量化</span>
        </h2>
        <form id="predict-form">
          <div class="feature-grid" id="feature-inputs"></div>
          <div class="control-row">
            <label>
              组合策略
              <select id="strategy-select"></select>
            </label>
            <label class="toggle">
              <input type="checkbox" id="uncertainty-toggle" />
              展示预测区间
            </label>
            <button type="submit">生成预测</button>
          </div>
        </form>
        <div class="result" id="prediction-result"></div>
        <div class="result" id="prediction-table"></div>
        <div class="result" id="uncertainty-result"></div>
      </section>

      <section class="panel" id="dataset-panel">
        <h2>
          数据概览
          <span class="badge">自动特征工程与质量扫描</span>
        </h2>
        <p class="section-lead">
          自动梳理数据质量、特征保留情况与集成权重，为后续建模提供清晰的事实基础。
        </p>
        <div class="stat-grid" id="dataset-stats"></div>
        <div class="grid-two">
          <div id="dataset-report" class="data-card"></div>
          <div id="feature-summary" class="data-card"></div>
        </div>
        <div class="grid-two" style="margin-top: 20px;">
          <div id="ensemble-weights" class="data-card"></div>
          <div id="stacking-weights" class="data-card"></div>
        </div>
        <div id="retained-features" class="data-card tag-cloud"></div>
        <div id="correlation-alerts" style="margin-top: 18px;"></div>
      </section>

      <section class="panel" id="metrics-panel">
        <h2>
          模型评估指标
          <span class="badge">全栈集成学习</span>
        </h2>
        <div id="metrics-table" class="data-card"></div>
      </section>

      <section class="panel" id="insights-panel">
        <h2>
          特征影响分析
          <span class="badge">SHAP &amp; 置换重要性</span>
        </h2>
        <div class="grid-two">
          <div id="permutation-importance" class="data-card"></div>
          <div id="shap-importance" class="data-card"></div>
        </div>
      </section>

      <section class="panel" id="optimization-panel">
        <h2>
          优化算法表现
          <span class="badge">多策略博弈</span>
        </h2>
        <div id="optimization-results" class="data-card"></div>
      </section>

      <section class="panel" id="monitor-panel">
        <h2>
          过程监控示例
          <span class="badge">动态阈值自适应</span>
        </h2>
        <div class="highlight-card" id="monitor-threshold"></div>
        <div id="monitor-log" class="data-card"></div>
      </section>
    </div>

    <script>
      const state = {
        features: [],
        strategies: [],
        weights: {},
        stackingWeights: {},
      };

      const strategyDisplayNames = {
        mean: '鲁棒平均 (mean)',
        equal: '等权融合 (equal)',
        residual: '残差反向加权 (residual)',
        self_adaption: '验证集自适应 (self_adaption)',
        stacking: '元学习集成 (stacking)',
        rf: '随机森林 (rf)',
        xgb: 'XGBoost (xgb)',
        mlp: '多层感知器 (mlp)',
        gbr: '梯度提升回归 (gbr)',
        hgb: '直方图梯度提升 (hgb)',
      };

      const strategyDescriptions = {
        mean: '对所有基础模型输出求平均，提供稳健基线表现。',
        equal:
          'XGBoost 与随机森林固定等权融合，适合作为快速上线的集成策略。',
        residual:
          '根据残差动态分配 XGBoost / RF 权重，让误差更小的模型贡献更大。',
        self_adaption:
          '在验证集上搜索最佳权重，实现对当前数据分布的自适应融合。',
        stacking:
          '以 RidgeCV 作为元学习器堆叠全部基础模型，兼顾精度与泛化能力。',
        rf: '基于袋装的树模型，擅长处理噪声与高维离散特征。',
        xgb: '梯度提升树高效建模非线性关系，是解释与精度的平衡选择。',
        mlp: '64×32 隐藏层的多层感知器，补充神经网络对复杂关系的表达力。',
        gbr:
          '传统梯度提升回归器，逐步逼近残差，为集成提供稳定基线。',
        hgb:
          '直方图梯度提升回归器，训练高效，适合大规模数据的快速建模。',
      };

      const baseModelDetails = {
        rf: {
          title: '随机森林（RandomForestRegressor）',
          description: '通过袋装思想降低方差，对噪声与异常点具备出色鲁棒性。',
          strengths: [
            '自动子采样特征，配合 out-of-bag 机制缓解过拟合风险。',
            '与置换重要性结合，能给出稳定可信的特征排序。',
          ],
        },
        xgb: {
          title: 'XGBoost 回归（XGBRegressor）',
          description: '梯度提升框架，支持正则化与列采样，兼具速度与精度。',
          strengths: [
            '提供 SHAP 值，量化每个特征对排放预测的边际影响。',
            '在多种融合策略中担纲主力模型，提升整体预测上限。',
          ],
        },
        mlp: {
          title: '多层感知器（MLPRegressor）',
          description: '两层全连接网络 (64→32)，捕捉更复杂的非线性结构。',
          strengths: [
            '补充树模型难以覆盖的平滑连续关系，提升模型多样性。',
            '在 Stacking 中提供神经网络视角，丰富集成表达能力。',
          ],
        },
        gbr: {
          title: '梯度提升回归（GradientBoostingRegressor）',
          description: '传统 boosting 基线，逐步拟合残差以提升精度。',
          strengths: [
            '训练稳定、可解释性良好，适合做策略回溯与对比。',
            '为堆叠模型提供稳健的中等复杂度预测信号。',
          ],
        },
        hgb: {
          title: '直方图梯度提升（HistGradientBoostingRegressor）',
          description: '基于直方图加速的 boosting，实现更快的迭代效率。',
          strengths: [
            '对大数据量依然保持快速训练，支撑高频策略试验。',
            '离散化直方图天然具备正则效果，提升泛化表现。',
          ],
        },
      };

      function sanitizeId(name) {
        return name.replace(/[^a-zA-Z0-9_-]/g, '-');
      }

      function createTable(headers, rows) {
        if (!rows.length) {
          return '<p class="muted">暂无数据</p>';
        }
        const thead =
          `<thead><tr>${headers.map((h) => `<th>${h}</th>`).join('')}</tr></thead>`;
        const tbody =
          `<tbody>${rows
            .map((row) =>
              `<tr>${row.map((cell) => `<td>${cell}</td>`).join('')}</tr>`,
            )
            .join('')}</tbody>`;
        return `<table class="data-table">${thead}${tbody}</table>`;
      }

      function formatWeightPair(weight) {
        if (!weight) {
          return '';
        }
        return Object.entries(weight)
          .map(
            ([name, value]) => `${name.toUpperCase()} ${(value * 100).toFixed(1)}%`,
          )
          .join(' · ');
      }

      function formatStackingWeights(weights) {
        if (!weights) {
          return '';
        }
        return Object.entries(weights)
          .sort(([, a], [, b]) => b - a)
          .map(
            ([name, value]) => `${name.toUpperCase()} ${(value * 100).toFixed(1)}%`,
          )
          .join(' · ');
      }

      function renderStrategyMap(strategies, weights, stackingWeights) {
        const container = document.getElementById('strategy-overview');
        if (!container) {
          return;
        }
        if (!strategies || !strategies.length) {
          container.innerHTML = '<p class="muted">暂无策略信息。</p>';
          return;
        }
        const unique = Array.from(new Set(strategies));
        const baseKeys = Object.keys(baseModelDetails);
        const ordered = [
          ...unique.filter((name) => !baseKeys.includes(name)),
          ...unique.filter((name) => baseKeys.includes(name)),
        ];
        const cards = ordered.map((name) => {
          const title = strategyDisplayNames[name] || name.toUpperCase();
          const description = strategyDescriptions[name] || '融合策略。';
          const detailLines = [];
          if (weights && weights[name]) {
            detailLines.push(`融合权重：${formatWeightPair(weights[name])}`);
          }
          if (name === 'stacking') {
            const stackingText = formatStackingWeights(stackingWeights);
            if (stackingText) {
              detailLines.push(`Stacking 权重：${stackingText}`);
            }
          }
          if (stackingWeights && stackingWeights[name] != null && baseKeys.includes(name)) {
            detailLines.push(
              `在 Stacking 中的贡献：${(stackingWeights[name] * 100).toFixed(1)}%`,
            );
          }
          const detail = detailLines.length
            ? `<p class="strategy-meta">${detailLines.join('<br />')}</p>`
            : '';
          return `<article class="strategy-card"><h3>${title}</h3><p>${description}</p>${detail}</article>`;
        });
        container.innerHTML = `<div class="strategy-grid">${cards.join('')}</div>`;
      }

      function renderModelHub(strategies, stackingWeights = {}) {
        const container = document.getElementById('model-hub');
        if (!container) {
          return;
        }
        const unique = Array.from(new Set(strategies || []));
        const base = unique.filter((name) => baseModelDetails[name]);
        if (!base.length) {
          container.innerHTML = '<p class="muted">暂无基础模型信息。</p>';
          return;
        }
        const cards = base.map((name) => {
          const detail = baseModelDetails[name];
          const items = detail.strengths
            .map((item) => `<li>${item}</li>`)
            .join('');
          const stackingShare = stackingWeights[name];
          const stackingInfo =
            stackingShare != null
              ? `<p class="strategy-meta">Stacking 权重贡献：${(
                  stackingShare * 100
                ).toFixed(1)}%</p>`
              : '';
          return [
            `<article class="model-card">`,
            `<h3>${detail.title}</h3>`,
            `<p>${detail.description}</p>`,
            `<ul>${items}</ul>`,
            stackingInfo,
            `</article>`,
          ].join('');
        });
        container.innerHTML = `<div class="model-grid">${cards.join('')}</div>`;
      }

      async function fetchJSON(url) {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`请求失败: ${response.status}`);
        }
        return response.json();
      }

      function renderFeatureInputs(features, strategies) {
        const container = document.getElementById('feature-inputs');
        container.innerHTML = '';
        features.forEach((feature) => {
          const id = `feature-${sanitizeId(feature)}`;
          const wrapper = document.createElement('label');
          wrapper.textContent = feature;
          const input = document.createElement('input');
          input.type = 'number';
          input.step = 'any';
          input.id = id;
          input.required = true;
          input.placeholder = '请输入数值';
          input.dataset.feature = feature;
          wrapper.appendChild(input);
          container.appendChild(wrapper);
        });
        const select = document.getElementById('strategy-select');
        select.innerHTML = '';
        strategies.forEach((strategy) => {
          const option = document.createElement('option');
          option.value = strategy;
          option.textContent = strategyDisplayNames[strategy] || strategy;
          select.appendChild(option);
        });
      }

      function renderReport(report, weights, stackingWeights) {
        if (!report) {
          return;
        }
        const formatInteger = (value) => {
          const num = Number(value);
          if (!Number.isFinite(num)) {
            return '-';
          }
          return new Intl.NumberFormat('zh-CN').format(Math.round(num));
        };

        const statsContainer = document.getElementById('dataset-stats');
        if (statsContainer) {
          const retainedFeatures = report.retained_features || [];
          const sampleCount = report.n_rows ?? 0;
          const engineeredCount = Math.max(
            retainedFeatures.length - (state.features?.length || 0),
            0,
          );
          const missingValues = Object.values(report.missing_rate || {});
          const avgMissing =
            missingValues.length > 0
              ? missingValues.reduce(
                  (acc, value) => acc + Number(value || 0),
                  0,
                ) / missingValues.length
              : 0;
          const qualityScore = Math.max(0, 100 - avgMissing * 100);
          const highCorrCount = (report.high_correlation_pairs || []).length;
          const stats = [
            {
              label: '清洗后样本',
              value: formatInteger(sampleCount),
              hint: '用于训练与验证的记录数',
            },
            {
              label: '建模特征',
              value: formatInteger(retainedFeatures.length),
              hint:
                engineeredCount > 0
                  ? `含派生特征 ${formatInteger(engineeredCount)} 项`
                  : '以业务关键字段为主',
            },
            {
              label: '数据稳定度',
              value: `${qualityScore.toFixed(1)}%`,
              hint:
                highCorrCount > 0
                  ? `高相关特征对：${formatInteger(highCorrCount)} 组`
                  : '已自动消除高共线性干扰',
            },
          ];
          statsContainer.innerHTML = stats
            .map(
              (item) => `
                <div class="stat-card">
                  <span class="stat-label">${item.label}</span>
                  <span class="stat-value">${item.value}</span>
                  <span class="stat-hint">${item.hint}</span>
                </div>
              `,
            )
            .join('');
        }

        const reportDiv = document.getElementById('dataset-report');
        if (reportDiv) {
          const rows = Object.entries(report.missing_rate || {})
            .sort(([, a], [, b]) => Number(b) - Number(a))
            .map(([feature, value]) => [
              feature,
              `${(Number(value) * 100).toFixed(2)}%`,
            ])
            .slice(0, 12);
          reportDiv.innerHTML = `
            <p class="card-title">字段缺失率（Top12）</p>
            ${createTable(['特征', '缺失率'], rows)}
          `;
        }

        const weightDiv = document.getElementById('ensemble-weights');
        if (weightDiv) {
          const weightRows = Object.entries(weights || {}).map(([name, pair]) => [
            strategyDisplayNames[name] || name,
            `${(pair.xgb * 100).toFixed(1)}%`,
            `${(pair.rf * 100).toFixed(1)}%`,
          ]);
          weightDiv.innerHTML = `
            <p class="card-title">双模型组合权重</p>
            ${createTable(['策略', 'XGB 权重', 'RF 权重'], weightRows)}
          `;
        }

        const stackingDiv = document.getElementById('stacking-weights');
        if (stackingDiv) {
          const stackRows = Object.entries(stackingWeights || {})
            .sort(([, a], [, b]) => Number(b) - Number(a))
            .map(([name, value]) => [
              strategyDisplayNames[name] || name.toUpperCase(),
              `${(value * 100).toFixed(1)}%`,
            ]);
          stackingDiv.innerHTML = `
            <p class="card-title">Stacking 元学习权重</p>
            ${createTable(['基础模型', '权重贡献'], stackRows)}
          `;
        }

        const summaryDiv = document.getElementById('feature-summary');
        if (summaryDiv) {
          const summaryEntries = Object.entries(report.feature_summary || {})
            .slice(0, 8)
            .map(([feature, stats]) => [
              feature,
              Number(stats.mean).toFixed(2),
              Number(stats.std).toFixed(2),
              Number(stats.min).toFixed(2),
              Number(stats.max).toFixed(2),
            ]);
          summaryDiv.innerHTML = `
            <p class="card-title">特征统计摘要（前 8 项）</p>
            ${createTable(['特征', '均值', '标准差', '最小值', '最大值'], summaryEntries)}
          `;
        }

        const retainedDiv = document.getElementById('retained-features');
        if (retainedDiv) {
          const retained = report.retained_features || [];
          if (retained.length) {
            const limit = 24;
            const visible = retained.slice(0, limit);
            const hiddenCount = Math.max(retained.length - visible.length, 0);
            retainedDiv.innerHTML = `
              <span class="card-title">最终建模特征 (${retained.length})</span>
              <div class="tag-list">
                ${visible.map((name) => `<span class="tag">${name}</span>`).join('')}
              </div>
              ${
                hiddenCount
                  ? `<p class="muted">其余 ${hiddenCount} 项已折叠，可在后端配置中查看完整列表。</p>`
                  : ''
              }
            `;
          } else {
            retainedDiv.innerHTML = '<p class="muted">暂无特征信息。</p>';
          }
        }

        const correlationDiv = document.getElementById('correlation-alerts');
        if (correlationDiv) {
          const correlationRows = (report.high_correlation_pairs || [])
            .slice(0, 6)
            .map((item) => [
              item.feature_a,
              item.feature_b,
              Number(item.correlation).toFixed(3),
            ]);
          correlationDiv.innerHTML = `
            <div class="highlight-card">
              <p class="card-title">高相关特征预警</p>
              ${createTable(['特征 A', '特征 B', '相关系数'], correlationRows)}
              <p class="muted">若相关性过高，将自动进行特征降维处理。</p>
            </div>
          `;
        }
      }

      function renderMetrics(metrics) {
        const container = document.getElementById('metrics-table');
        if (!metrics) {
          container.innerHTML = '<p class="muted">暂无指标信息。</p>';
          return;
        }
        const rows = [];
        Object.entries(metrics.base_models || {}).forEach(([name, values]) => {
          rows.push([
            `基础-${name}`,
            values.r2.toFixed(3),
            `${(values.mape * 100).toFixed(2)}%`,
            values.mae.toFixed(3),
            values.rmse.toFixed(3),
          ]);
        });
        Object.entries(metrics.ensembles || {}).forEach(([name, values]) => {
          rows.push([
            `组合-${name}`,
            values.r2.toFixed(3),
            `${(values.mape * 100).toFixed(2)}%`,
            values.mae.toFixed(3),
            values.rmse.toFixed(3),
          ]);
        });
        container.innerHTML = createTable(
          ['模型', 'R²', 'MAPE', 'MAE', 'RMSE'],
          rows,
        );
      }

      function renderPermutation(data) {
        const container = document.getElementById('permutation-importance');
        if (!data || !data.length) {
          container.innerHTML = '<p class="muted">暂未生成置换重要性。</p>';
          return;
        }
        const rows = data.map((item) => [
          item.feature,
          item.importance.toFixed(4),
        ]);
        container.innerHTML = `
          <p class="card-title">置换重要性（随机森林）</p>
          ${createTable(['特征', '重要性'], rows)}
        `;
      }

      function renderShap(shap) {
        const container = document.getElementById('shap-importance');
        if (!shap) {
          container.innerHTML = '<p class="muted">SHAP 分析不可用。</p>';
          return;
        }
        const sections = Object.entries(shap)
          .map(([name, values]) => {
            const rows = values.map((item) => [
              item.feature,
              item.importance.toFixed(4),
            ]);
            const label = strategyDisplayNames[name] || name.toUpperCase();
            return `
              <div class="sub-card">
                <p class="card-title">${label} 平均 |SHAP|</p>
                ${createTable(['特征', '影响力'], rows)}
              </div>
            `;
          })
          .join('');
        container.innerHTML = sections;
      }

      function renderOptimization(data) {
        const container = document.getElementById('optimization-results');
        if (!data) {
          container.innerHTML = '<p class="muted">暂无优化结果。</p>';
          return;
        }
        const { experiments = [], summary = [] } = data;
        const experimentRows = experiments.map((item) => [
          item.algorithm,
          `[${(item.best_params || [])
            .map((value) => value.toFixed(2))
            .join(', ')}]`,
          item.best_val.toFixed(3),
        ]);
        const summaryRows = summary.map((item) => [
          item.algorithm,
          item.best_params,
          item.best_val,
          item.iterations,
        ]);
        container.innerHTML = `
          <p class="card-title">最新实验最佳结果</p>
          ${createTable(['算法', '最佳参数', '目标值'], experimentRows)}
          <div class="card-separator"></div>
          <p class="card-title">实验日志概览</p>
          ${createTable(['算法', '最佳参数', '目标值', '迭代数'], summaryRows)}
        `;
      }

      function renderMonitor(log) {
        const container = document.getElementById('monitor-log');
        const thresholdCard = document.getElementById('monitor-threshold');
        if (thresholdCard) {
          if (log && typeof log.threshold === 'number') {
            thresholdCard.innerHTML = `
              <div class="status-pill">报警阈值 ${log.threshold.toFixed(2)}</div>
              <p class="muted">超过阈值即触发多策略协同优化。</p>
            `;
          } else {
            thresholdCard.innerHTML = '<p class="muted">监控阈值未定义。</p>';
          }
        }
        if (!log || !Array.isArray(log.log) || !log.log.length) {
          container.innerHTML = '<p class="muted">暂无监控记录。</p>';
          return;
        }
        const rows = log.log.map((item) => [
          item.step,
          item.actual !== null ? item.actual.toFixed(2) : '-',
          item.predicted !== null ? item.predicted.toFixed(2) : '-',
          item.action
            ? `[${item.action.map((value) => value.toFixed(2)).join(', ')}]`
            : '无',
          item.value.toFixed(2),
          item.forced
            ? '强制调优'
            : item.action
            ? '自动调优'
            : '常规监控',
        ]);
        container.innerHTML = `
          <p class="card-title">监控日志</p>
          ${createTable(
            ['步骤', '实际值', '预测值', '优化动作', '目标函数', '状态'],
            rows,
          )}
        `;
      }

      async function initDashboard() {
        try {
          const metadata = await fetchJSON('/metadata');
          state.features = metadata.features || [];
          state.strategies = metadata.strategies || [];
          state.weights = metadata.ensemble_weights || {};
          state.stackingWeights = metadata.stacking_weights || {};
          renderFeatureInputs(state.features, state.strategies);
          renderStrategyMap(
            state.strategies,
            state.weights,
            state.stackingWeights,
          );
          renderModelHub(state.strategies, state.stackingWeights);
          renderReport(
            metadata.report,
            state.weights,
            state.stackingWeights,
          );
          const metrics = await fetchJSON('/metrics');
          renderMetrics(metrics);
          const insights = await fetchJSON('/feature-insights');
          renderPermutation(insights.permutation_importance);
          renderShap(insights.shap_summary);
          const optimization = await fetchJSON('/optimization');
          renderOptimization(optimization);
          const monitor = await fetchJSON('/monitor-sample');
          renderMonitor(monitor);
        } catch (error) {
          document.getElementById('prediction-result').innerHTML =
            `<p class="error">初始化失败：${error.message}</p>`;
        }
      }

      async function handlePredict(event) {
        event.preventDefault();
        const inputs = Array.from(
          document.querySelectorAll('#feature-inputs input'),
        );
        const payload = {};
        for (const input of inputs) {
          const value = input.value;
          if (value === '') {
            input.focus();
            return;
          }
          payload[input.dataset.feature] = Number(value);
        }
        const strategy = document.getElementById('strategy-select').value;
        const includeUncertainty = document.getElementById('uncertainty-toggle').checked;
        try {
          const response = await fetch(
            `/predict?strategy=${encodeURIComponent(strategy)}&all_strategies=true&uncertainty=${includeUncertainty}`,
            {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            },
          );
          const data = await response.json();
          const uncertaintyDiv = document.getElementById('uncertainty-result');
          uncertaintyDiv.innerHTML = '';
          if (response.ok && data.predictions) {
            document.getElementById('prediction-result').textContent =
              '预测已生成，详见下表。';
            const rows = Object.entries(data.predictions).map(
              ([name, values]) => [
                name,
                values.map((value) => Number(value).toFixed(2)).join(', '),
              ],
            );
            document.getElementById('prediction-table').innerHTML = createTable(
              ['策略', '预测值'],
              rows,
            );
            if (data.uncertainty) {
              const lower = data.uncertainty.lower.map((value) => Number(value).toFixed(2));
              const upper = data.uncertainty.upper.map((value) => Number(value).toFixed(2));
              const center = data.uncertainty.prediction.map((value) => Number(value).toFixed(2));
              uncertaintyDiv.innerHTML =
                `<div class="highlight-card">` +
                `<strong>区间 (${data.uncertainty.strategy}):</strong> ` +
                center
                  .map((value, idx) => `${value} [${lower[idx]}, ${upper[idx]}]`)
                  .join('， ') +
                '</div>';
            }
          } else if (response.ok && data.prediction) {
            document.getElementById('prediction-result').textContent =
              `预测结果 (${data.strategy}): ${data.prediction
                .map((value) => Number(value).toFixed(2))
                .join(', ')}`;
            document.getElementById('prediction-table').innerHTML = '';
            if (data.lower && data.upper) {
              const intervalText = data.lower
                .map((value, idx) =>
                  `${Number(data.prediction[idx]).toFixed(2)} ` +
                  `[${Number(value).toFixed(2)}, ${Number(data.upper[idx]).toFixed(2)}]`,
                )
                .join('， ');
              uncertaintyDiv.innerHTML =
                `<div class="highlight-card">预测区间：${intervalText}</div>`;
            }
          } else {
            throw new Error(data.error || '未知错误');
          }
        } catch (error) {
          document.getElementById('prediction-result').innerHTML =
            `<p class="error">预测失败：${error.message}</p>`;
          document.getElementById('prediction-table').innerHTML = '';
          document.getElementById('uncertainty-result').innerHTML = '';
        }
      }

      document
        .getElementById('predict-form')
        .addEventListener('submit', handlePredict);
      document.addEventListener('DOMContentLoaded', initDashboard);
    </script>
  </body>
</html>
