<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <title>智能排放管控驾驶舱</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/modern-css-reset@1.4.0/dist/reset.min.css"
    />
    <style>
      body {
        font-family: "Segoe UI", Arial, sans-serif;
        background: linear-gradient(180deg, #eff6ff 0%, #f8fafc 100%);
        color: #0f172a;
      }

      .container {
        max-width: 1180px;
        margin: 36px auto 48px;
        padding: 0 18px 48px;
      }

      header {
        text-align: center;
        margin-bottom: 32px;
      }

      header h1 {
        font-size: 2.2rem;
        font-weight: 700;
        margin-bottom: 10px;
        letter-spacing: 0.04em;
      }

      header p {
        font-size: 1.1rem;
        color: #475569;
        line-height: 1.6;
      }

      .panel {
        background: #fff;
        border-radius: 14px;
        box-shadow: 0 18px 40px rgba(15, 23, 42, 0.12);
        padding: 26px;
        margin-bottom: 26px;
        border: 1px solid rgba(148, 163, 184, 0.2);
      }

      h2 {
        font-size: 1.4rem;
        margin-bottom: 14px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      h2 span {
        font-size: 0.9rem;
        color: #64748b;
        font-weight: 500;
      }

      form {
        display: grid;
        gap: 18px;
      }

      .feature-grid {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }

      .feature-grid label {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 0.9rem;
        color: #334155;
      }

      .feature-grid input {
        padding: 10px;
        border: 1px solid #cbd5e1;
        border-radius: 8px;
        font-size: 1rem;
        transition: border 0.2s ease;
      }

      .feature-grid input:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.12);
      }

      .control-row {
        display: flex;
        flex-wrap: wrap;
        gap: 14px;
        align-items: center;
      }

      select,
      button {
        padding: 10px 16px;
        border-radius: 8px;
        border: 1px solid #94a3b8;
        font-size: 1rem;
      }

      button {
        background: linear-gradient(135deg, #2563eb, #7c3aed);
        color: #fff;
        border: none;
        cursor: pointer;
        font-weight: 600;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 20px rgba(37, 99, 235, 0.25);
      }

      code {
        font-family: 'Fira Code', 'Consolas', monospace;
        background: rgba(15, 23, 42, 0.06);
        padding: 2px 6px;
        border-radius: 6px;
        font-size: 0.85rem;
      }

      .toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.95rem;
        color: #475569;
      }

      .toggle input {
        width: 18px;
        height: 18px;
      }

      .result {
        margin-top: 12px;
        font-size: 1rem;
        color: #0f172a;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 12px;
      }

      th,
      td {
        border: 1px solid #e2e8f0;
        padding: 8px 10px;
        text-align: left;
        font-size: 0.95rem;
      }

      th {
        background: #f8fafc;
        font-weight: 600;
      }

      caption {
        text-align: left;
        margin-bottom: 8px;
        font-weight: 600;
        color: #334155;
      }

      .grid-two {
        display: grid;
        gap: 18px;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }

      .muted {
        color: #64748b;
        font-size: 0.9rem;
      }

      .error {
        color: #dc2626;
        margin-top: 10px;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        background: rgba(37, 99, 235, 0.08);
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 0.85rem;
        color: #1d4ed8;
      }

      .highlight-card {
        padding: 16px;
        border-radius: 12px;
        border: 1px solid rgba(226, 232, 240, 0.9);
        background: rgba(248, 250, 252, 0.8);
      }

      .capability-grid,
      .strategy-grid,
      .model-grid {
        display: grid;
        gap: 18px;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }

      .capability-card,
      .strategy-card,
      .model-card {
        padding: 18px;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: linear-gradient(180deg, #f8fafc 0%, #ffffff 100%);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
      }

      .capability-card h3,
      .strategy-card h3,
      .model-card h3 {
        font-size: 1.1rem;
        margin-bottom: 8px;
      }

      .capability-card p,
      .strategy-card p,
      .model-card p {
        color: #475569;
        line-height: 1.6;
        margin-bottom: 10px;
      }

      .capability-card ul,
      .model-card ul {
        margin: 0;
        padding-left: 18px;
        color: #334155;
        line-height: 1.5;
      }

      .strategy-meta {
        color: #1d4ed8;
        font-size: 0.9rem;
        font-weight: 500;
      }

      .workflow {
        display: grid;
        gap: 16px;
      }

      .workflow-step {
        border-left: 3px solid rgba(37, 99, 235, 0.35);
        padding-left: 16px;
      }

      .workflow-step h3 {
        font-size: 1.05rem;
        margin-bottom: 6px;
      }

      .workflow-step span {
        display: inline-block;
        background: rgba(37, 99, 235, 0.12);
        color: #1d4ed8;
        font-size: 0.85rem;
        font-weight: 600;
        padding: 2px 10px;
        border-radius: 999px;
        margin-bottom: 6px;
      }

      .workflow-step p {
        color: #475569;
        line-height: 1.6;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>智能排放管控驾驶舱</h1>
        <p>
          一站式洞察数据质量、模型表现、特征影响与优化策略，实时掌握排放风险，先人一步做出高阶决策。
        </p>
      </header>

      <section class="panel" id="capability-panel">
        <h2>
          平台能力全景
          <span class="badge">数据 · 建模 · 优化 · 运维 一体化</span>
        </h2>
        <div class="capability-grid">
          <article class="capability-card">
            <h3>数据智能引擎</h3>
            <p>
              基于 <code>data_preprocessing.py</code> 的自动化流水线，确保不同来源的原始数据在分钟级完成治理。
            </p>
            <ul>
              <li>CSV / SQLite 多源导入与中文字段智能映射。</li>
              <li>缺失值填补、异常值剔除、数值化与标准化全流程。</li>
              <li>构建平方项、比值、对数等领域特征并自动消除共线性。</li>
            </ul>
          </article>
          <article class="capability-card">
            <h3>模型融合引擎</h3>
            <p>
              <code>ModelManager</code> 同时管理五大回归器，并提供多种策略以满足不同业务场景的精度与稳定性需求。
            </p>
            <ul>
              <li>mean / equal / residual / self_adaption / stacking 多策略一键切换。</li>
              <li>输出 R²、MAPE、MAE、RMSE 全量评估指标与不确定性区间。</li>
              <li>支持 SHAP 与 permutation importance 深入解释特征贡献。</li>
            </ul>
          </article>
          <article class="capability-card">
            <h3>优化决策大脑</h3>
            <p>
              <code>optimization.py</code> 与 <code>ExperimentManager</code> 组成的智能实验平台，为排放控制策略提供实时迭代能力。
            </p>
            <ul>
              <li>内置 PSO、贝叶斯、遗传算法多策略对 <code>emission_objective</code> 迭代寻优。</li>
              <li>实验日志、最优参数与目标值完整留痕，便于对比复盘。</li>
              <li>ProcessMonitor 异常触发自动调优，阈值策略可通过 Config 自定义。</li>
            </ul>
          </article>
          <article class="capability-card">
            <h3>工程化运维保障</h3>
            <p>
              自带 API、模型版本化与测试脚本，帮助团队快速落地并持续交付。
            </p>
            <ul>
              <li>Flask 服务暴露 /predict、/metadata 等接口即插即用。</li>
              <li>模型工件通过 Joblib 版本化持久化，方便部署回滚。</li>
              <li><code>main.py</code> 与 <code>tests/</code> 提供离线验证与冒烟测试保障。</li>
            </ul>
          </article>
        </div>
      </section>

      <section class="panel" id="workflow-panel">
        <h2>
          闭环工作流
          <span class="badge">从数据到决策的每一步都可追溯</span>
        </h2>
        <div class="workflow">
          <div class="workflow-step">
            <span>Step 01</span>
            <h3>数据导入与治理</h3>
            <p>
              <code>load_training_frame</code> 自动识别外部数据源，配合清洗、字段映射与缺失值处理，生成高质量原始数据集。
            </p>
          </div>
          <div class="workflow-step">
            <span>Step 02</span>
            <h3>特征构建与筛选</h3>
            <p>
              通过比值、平方、对数等特征工程与共线性消除策略，形成可用于建模的稳健特征矩阵与质量报告。
            </p>
          </div>
          <div class="workflow-step">
            <span>Step 03</span>
            <h3>多模型集成训练</h3>
            <p>
              <code>ModelManager</code> 统一训练随机森林、XGBoost、MLP 等模型，并自动计算集成权重与元学习 Stacking 模型。
            </p>
          </div>
          <div class="workflow-step">
            <span>Step 04</span>
            <h3>智能优化与监控</h3>
            <p>
              ExperimentManager 运行多策略实验，ProcessMonitor 实时监听并触发 PSO / GA / 贝叶斯调优，形成动态阈值控制。
            </p>
          </div>
          <div class="workflow-step">
            <span>Step 05</span>
            <h3>可视化与服务化交付</h3>
            <p>
              Flask API 与本驾驶舱页面提供在线预测、指标监控、特征洞察，帮助业务快速验证与部署减排策略。
            </p>
          </div>
        </div>
      </section>

      <section class="panel" id="strategy-panel">
        <h2>
          集成策略地图
          <span class="badge">自适应融合与单模直推一览</span>
        </h2>
        <p class="muted">
          策略描述与权重来自后端实时同步，可帮助快速理解不同组合在当前数据下的决策特点。
        </p>
        <div id="strategy-overview">
          <p class="muted">策略信息加载中…</p>
        </div>
      </section>

      <section class="panel" id="model-panel">
        <h2>
          模型家族能力
          <span class="badge">基础模型优势速览</span>
        </h2>
        <p class="muted">
          所有基础模型均由 <code>ModelManager</code> 统一训练与调度，以下亮点帮助快速匹配业务场景。
        </p>
        <div id="model-hub">
          <p class="muted">模型详情加载中…</p>
        </div>
      </section>

      <section class="panel" id="prediction-panel">
        <h2>
          在线预测
          <span class="badge">支持策略组合 &amp; 不确定性量化</span>
        </h2>
        <form id="predict-form">
          <div class="feature-grid" id="feature-inputs"></div>
          <div class="control-row">
            <label>
              组合策略
              <select id="strategy-select"></select>
            </label>
            <label class="toggle">
              <input type="checkbox" id="uncertainty-toggle" />
              展示预测区间
            </label>
            <button type="submit">生成预测</button>
          </div>
        </form>
        <div class="result" id="prediction-result"></div>
        <div class="result" id="prediction-table"></div>
        <div class="result" id="uncertainty-result"></div>
      </section>

      <section class="panel" id="dataset-panel">
        <h2>
          数据概览
          <span class="badge">自动特征工程与质量扫描</span>
        </h2>
        <div class="grid-two">
          <div id="dataset-report"></div>
          <div id="feature-summary"></div>
        </div>
        <div class="grid-two" style="margin-top: 18px;">
          <div id="ensemble-weights"></div>
          <div id="stacking-weights"></div>
        </div>
        <div id="correlation-alerts" style="margin-top: 16px;"></div>
      </section>

      <section class="panel" id="metrics-panel">
        <h2>
          模型评估指标
          <span class="badge">全栈集成学习</span>
        </h2>
        <div id="metrics-table"></div>
      </section>

      <section class="panel" id="insights-panel">
        <h2>
          特征影响分析
          <span class="badge">SHAP &amp; 置换重要性</span>
        </h2>
        <div class="grid-two">
          <div id="permutation-importance"></div>
          <div id="shap-importance"></div>
        </div>
      </section>

      <section class="panel" id="optimization-panel">
        <h2>
          优化算法表现
          <span class="badge">多策略博弈</span>
        </h2>
        <div id="optimization-results"></div>
      </section>

      <section class="panel" id="monitor-panel">
        <h2>
          过程监控示例
          <span class="badge">动态阈值自适应</span>
        </h2>
        <div id="monitor-log"></div>
      </section>
    </div>

    <script>
      const state = {
        features: [],
        strategies: [],
        weights: {},
        stackingWeights: {},
      };

      const strategyDisplayNames = {
        mean: '鲁棒平均 (mean)',
        equal: '等权融合 (equal)',
        residual: '残差反向加权 (residual)',
        self_adaption: '验证集自适应 (self_adaption)',
        stacking: '元学习集成 (stacking)',
        rf: '随机森林 (rf)',
        xgb: 'XGBoost (xgb)',
        mlp: '多层感知器 (mlp)',
        gbr: '梯度提升回归 (gbr)',
        hgb: '直方图梯度提升 (hgb)',
      };

      const strategyDescriptions = {
        mean: '对所有基础模型输出求平均，提供稳健基线表现。',
        equal:
          'XGBoost 与随机森林固定等权融合，适合作为快速上线的集成策略。',
        residual:
          '根据残差动态分配 XGBoost / RF 权重，让误差更小的模型贡献更大。',
        self_adaption:
          '在验证集上搜索最佳权重，实现对当前数据分布的自适应融合。',
        stacking:
          '以 RidgeCV 作为元学习器堆叠全部基础模型，兼顾精度与泛化能力。',
        rf: '基于袋装的树模型，擅长处理噪声与高维离散特征。',
        xgb: '梯度提升树高效建模非线性关系，是解释与精度的平衡选择。',
        mlp: '64×32 隐藏层的多层感知器，补充神经网络对复杂关系的表达力。',
        gbr:
          '传统梯度提升回归器，逐步逼近残差，为集成提供稳定基线。',
        hgb:
          '直方图梯度提升回归器，训练高效，适合大规模数据的快速建模。',
      };

      const baseModelDetails = {
        rf: {
          title: '随机森林（RandomForestRegressor）',
          description: '通过袋装思想降低方差，对噪声与异常点具备出色鲁棒性。',
          strengths: [
            '自动子采样特征，配合 out-of-bag 机制缓解过拟合风险。',
            '与置换重要性结合，能给出稳定可信的特征排序。',
          ],
        },
        xgb: {
          title: 'XGBoost 回归（XGBRegressor）',
          description: '梯度提升框架，支持正则化与列采样，兼具速度与精度。',
          strengths: [
            '提供 SHAP 值，量化每个特征对排放预测的边际影响。',
            '在多种融合策略中担纲主力模型，提升整体预测上限。',
          ],
        },
        mlp: {
          title: '多层感知器（MLPRegressor）',
          description: '两层全连接网络 (64→32)，捕捉更复杂的非线性结构。',
          strengths: [
            '补充树模型难以覆盖的平滑连续关系，提升模型多样性。',
            '在 Stacking 中提供神经网络视角，丰富集成表达能力。',
          ],
        },
        gbr: {
          title: '梯度提升回归（GradientBoostingRegressor）',
          description: '传统 boosting 基线，逐步拟合残差以提升精度。',
          strengths: [
            '训练稳定、可解释性良好，适合做策略回溯与对比。',
            '为堆叠模型提供稳健的中等复杂度预测信号。',
          ],
        },
        hgb: {
          title: '直方图梯度提升（HistGradientBoostingRegressor）',
          description: '基于直方图加速的 boosting，实现更快的迭代效率。',
          strengths: [
            '对大数据量依然保持快速训练，支撑高频策略试验。',
            '离散化直方图天然具备正则效果，提升泛化表现。',
          ],
        },
      };

      function sanitizeId(name) {
        return name.replace(/[^a-zA-Z0-9_-]/g, '-');
      }

      function createTable(headers, rows) {
        if (!rows.length) {
          return '<p class="muted">暂无数据</p>';
        }
        const thead =
          `<thead><tr>${headers.map((h) => `<th>${h}</th>`).join('')}</tr></thead>`;
        const tbody =
          `<tbody>${rows
            .map((row) =>
              `<tr>${row.map((cell) => `<td>${cell}</td>`).join('')}</tr>`,
            )
            .join('')}</tbody>`;
        return `<table>${thead}${tbody}</table>`;
      }

      function formatWeightPair(weight) {
        if (!weight) {
          return '';
        }
        return Object.entries(weight)
          .map(
            ([name, value]) => `${name.toUpperCase()} ${(value * 100).toFixed(1)}%`,
          )
          .join(' · ');
      }

      function formatStackingWeights(weights) {
        if (!weights) {
          return '';
        }
        return Object.entries(weights)
          .sort(([, a], [, b]) => b - a)
          .map(
            ([name, value]) => `${name.toUpperCase()} ${(value * 100).toFixed(1)}%`,
          )
          .join(' · ');
      }

      function renderStrategyMap(strategies, weights, stackingWeights) {
        const container = document.getElementById('strategy-overview');
        if (!container) {
          return;
        }
        if (!strategies || !strategies.length) {
          container.innerHTML = '<p class="muted">暂无策略信息。</p>';
          return;
        }
        const unique = Array.from(new Set(strategies));
        const baseKeys = Object.keys(baseModelDetails);
        const ordered = [
          ...unique.filter((name) => !baseKeys.includes(name)),
          ...unique.filter((name) => baseKeys.includes(name)),
        ];
        const cards = ordered.map((name) => {
          const title = strategyDisplayNames[name] || name.toUpperCase();
          const description = strategyDescriptions[name] || '融合策略。';
          const detailLines = [];
          if (weights && weights[name]) {
            detailLines.push(`融合权重：${formatWeightPair(weights[name])}`);
          }
          if (name === 'stacking') {
            const stackingText = formatStackingWeights(stackingWeights);
            if (stackingText) {
              detailLines.push(`Stacking 权重：${stackingText}`);
            }
          }
          if (stackingWeights && stackingWeights[name] != null && baseKeys.includes(name)) {
            detailLines.push(
              `在 Stacking 中的贡献：${(stackingWeights[name] * 100).toFixed(1)}%`,
            );
          }
          const detail = detailLines.length
            ? `<p class="strategy-meta">${detailLines.join('<br />')}</p>`
            : '';
          return `<article class="strategy-card"><h3>${title}</h3><p>${description}</p>${detail}</article>`;
        });
        container.innerHTML = `<div class="strategy-grid">${cards.join('')}</div>`;
      }

      function renderModelHub(strategies, stackingWeights = {}) {
        const container = document.getElementById('model-hub');
        if (!container) {
          return;
        }
        const unique = Array.from(new Set(strategies || []));
        const base = unique.filter((name) => baseModelDetails[name]);
        if (!base.length) {
          container.innerHTML = '<p class="muted">暂无基础模型信息。</p>';
          return;
        }
        const cards = base.map((name) => {
          const detail = baseModelDetails[name];
          const items = detail.strengths
            .map((item) => `<li>${item}</li>`)
            .join('');
          const stackingShare = stackingWeights[name];
          const stackingInfo =
            stackingShare != null
              ? `<p class="strategy-meta">Stacking 权重贡献：${(
                  stackingShare * 100
                ).toFixed(1)}%</p>`
              : '';
          return [
            `<article class="model-card">`,
            `<h3>${detail.title}</h3>`,
            `<p>${detail.description}</p>`,
            `<ul>${items}</ul>`,
            stackingInfo,
            `</article>`,
          ].join('');
        });
        container.innerHTML = `<div class="model-grid">${cards.join('')}</div>`;
      }

      async function fetchJSON(url) {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`请求失败: ${response.status}`);
        }
        return response.json();
      }

      function renderFeatureInputs(features, strategies) {
        const container = document.getElementById('feature-inputs');
        container.innerHTML = '';
        features.forEach((feature) => {
          const id = `feature-${sanitizeId(feature)}`;
          const wrapper = document.createElement('label');
          wrapper.textContent = feature;
          const input = document.createElement('input');
          input.type = 'number';
          input.step = 'any';
          input.id = id;
          input.required = true;
          input.dataset.feature = feature;
          wrapper.appendChild(input);
          container.appendChild(wrapper);
        });
        const select = document.getElementById('strategy-select');
        select.innerHTML = '';
        strategies.forEach((strategy) => {
          const option = document.createElement('option');
          option.value = strategy;
          option.textContent = strategy;
          select.appendChild(option);
        });
      }

      function renderReport(report, weights, stackingWeights) {
        if (!report) {
          return;
        }
        const reportDiv = document.getElementById('dataset-report');
        const rows = Object.entries(report.missing_rate || {}).map(
          ([feature, value]) => [feature, `${(value * 100).toFixed(2)}%`],
        );
        rows.unshift(['记录数', report.n_rows ?? 0]);
        reportDiv.innerHTML = `<caption>数据质量</caption>${createTable(
          ['指标', '数值'],
          rows,
        )}`;

        const weightDiv = document.getElementById('ensemble-weights');
        const weightRows = Object.entries(weights || {}).map(([name, pair]) => [
          name,
          `${(pair.xgb * 100).toFixed(1)}%`,
          `${(pair.rf * 100).toFixed(1)}%`,
        ]);
        weightDiv.innerHTML =
          `<caption>双模型组合权重（XGBoost / 随机森林）</caption>${createTable(
            ['策略', 'XGB 权重', 'RF 权重'],
            weightRows,
          )}`;

        const stackingDiv = document.getElementById('stacking-weights');
        const stackRows = Object.entries(stackingWeights || {}).map(
          ([name, value]) => [name, `${(value * 100).toFixed(1)}%`],
        );
        stackingDiv.innerHTML =
          `<caption>Stacking 元学习权重</caption>${createTable(
            ['基础模型', '权重贡献'],
            stackRows,
          )}`;

        const summaryDiv = document.getElementById('feature-summary');
        const summaryEntries = Object.entries(report.feature_summary || {})
          .slice(0, 8)
          .map(([feature, stats]) => [
            feature,
            Number(stats.mean).toFixed(2),
            Number(stats.std).toFixed(2),
            Number(stats.min).toFixed(2),
            Number(stats.max).toFixed(2),
          ]);
        summaryDiv.innerHTML =
          `<caption>特征统计摘要（前 8 项）</caption>${createTable(
            ['特征', '均值', '标准差', '最小值', '最大值'],
            summaryEntries,
          )}`;

        const correlationDiv = document.getElementById('correlation-alerts');
        const correlationRows = (report.high_correlation_pairs || [])
          .slice(0, 6)
          .map((item) => [
            item.feature_a,
            item.feature_b,
            item.correlation.toFixed(3),
          ]);
        correlationDiv.innerHTML =
          `<div class="highlight-card">${createTable(
            ['特征 A', '特征 B', '相关系数'],
            correlationRows,
          )}
            <p class="muted">若相关性过高，将自动进行特征降维处理。</p>
          </div>`;
      }

      function renderMetrics(metrics) {
        const container = document.getElementById('metrics-table');
        if (!metrics) {
          container.innerHTML = '<p class="muted">暂无指标信息。</p>';
          return;
        }
        const rows = [];
        Object.entries(metrics.base_models || {}).forEach(([name, values]) => {
          rows.push([
            `基础-${name}`,
            values.r2.toFixed(3),
            `${(values.mape * 100).toFixed(2)}%`,
            values.mae.toFixed(3),
            values.rmse.toFixed(3),
          ]);
        });
        Object.entries(metrics.ensembles || {}).forEach(([name, values]) => {
          rows.push([
            `组合-${name}`,
            values.r2.toFixed(3),
            `${(values.mape * 100).toFixed(2)}%`,
            values.mae.toFixed(3),
            values.rmse.toFixed(3),
          ]);
        });
        container.innerHTML = createTable(
          ['模型', 'R²', 'MAPE', 'MAE', 'RMSE'],
          rows,
        );
      }

      function renderPermutation(data) {
        const container = document.getElementById('permutation-importance');
        if (!data || !data.length) {
          container.innerHTML = '<p class="muted">暂未生成置换重要性。</p>';
          return;
        }
        const rows = data.map((item) => [
          item.feature,
          item.importance.toFixed(4),
        ]);
        container.innerHTML =
          `<caption>置换重要性（随机森林）</caption>${createTable(
            ['特征', '重要性'],
            rows,
          )}`;
      }

      function renderShap(shap) {
        const container = document.getElementById('shap-importance');
        if (!shap) {
          container.innerHTML = '<p class="muted">SHAP 分析不可用。</p>';
          return;
        }
        const sections = Object.entries(shap)
          .map(([name, values]) => {
            const rows = values.map((item) => [
              item.feature,
              item.importance.toFixed(4),
            ]);
            const panelStyle = 'box-shadow:none;padding:0;margin:0 0 16px 0;';
            return [
              `<div class="panel" style="${panelStyle}">`,
              `<caption>${name.toUpperCase()} 平均 |SHAP|</caption>${createTable(
                ['特征', '影响力'],
                rows,
              )}`,
              '</div>',
            ].join('');
          })
          .join('');
        container.innerHTML = sections;
      }

      function renderOptimization(data) {
        const container = document.getElementById('optimization-results');
        if (!data) {
          container.innerHTML = '<p class="muted">暂无优化结果。</p>';
          return;
        }
        const { experiments = [], summary = [] } = data;
        const experimentRows = experiments.map((item) => [
          item.algorithm,
          `[${(item.best_params || [])
            .map((value) => value.toFixed(2))
            .join(', ')}]`,
          item.best_val.toFixed(3),
        ]);
        const summaryRows = summary.map((item) => [
          item.algorithm,
          item.best_params,
          item.best_val,
          item.iterations,
        ]);
        container.innerHTML =
          `<caption>最新实验最佳结果</caption>${createTable(
            ['算法', '最佳参数', '目标值'],
            experimentRows,
          )}
    <caption>实验日志概览</caption>${createTable(
      ['算法', '最佳参数', '目标值', '迭代数'],
      summaryRows,
    )}`;
      }

      function renderMonitor(log) {
        const container = document.getElementById('monitor-log');
        if (!log || !log.log) {
          container.innerHTML = '<p class="muted">暂无监控记录。</p>';
          return;
        }
        const rows = log.log.map((item) => [
          item.step,
          item.actual !== null ? item.actual.toFixed(2) : '-',
          item.predicted !== null ? item.predicted.toFixed(2) : '-',
          item.action
            ? `[${item.action.map((value) => value.toFixed(2)).join(', ')}]`
            : '无',
          item.value.toFixed(2),
          item.forced ? '强制调整' : '',
        ]);
        container.innerHTML =
          `<p class="muted">当前阈值：${log.threshold.toFixed(2)}</p>${createTable(
            ['步骤', '实际值', '预测值', '优化动作', '输出', '说明'],
            rows,
          )}`;
      }

      async function initDashboard() {
        try {
          const metadata = await fetchJSON('/metadata');
          state.features = metadata.features || [];
          state.strategies = metadata.strategies || [];
          state.weights = metadata.ensemble_weights || {};
          state.stackingWeights = metadata.stacking_weights || {};
          renderFeatureInputs(state.features, state.strategies);
          renderStrategyMap(
            state.strategies,
            state.weights,
            state.stackingWeights,
          );
          renderModelHub(state.strategies, state.stackingWeights);
          renderReport(
            metadata.report,
            state.weights,
            state.stackingWeights,
          );
          const metrics = await fetchJSON('/metrics');
          renderMetrics(metrics);
          const insights = await fetchJSON('/feature-insights');
          renderPermutation(insights.permutation_importance);
          renderShap(insights.shap_summary);
          const optimization = await fetchJSON('/optimization');
          renderOptimization(optimization);
          const monitor = await fetchJSON('/monitor-sample');
          renderMonitor(monitor);
        } catch (error) {
          document.getElementById('prediction-result').innerHTML =
            `<p class="error">初始化失败：${error.message}</p>`;
        }
      }

      async function handlePredict(event) {
        event.preventDefault();
        const inputs = Array.from(
          document.querySelectorAll('#feature-inputs input'),
        );
        const payload = {};
        for (const input of inputs) {
          const value = input.value;
          if (value === '') {
            input.focus();
            return;
          }
          payload[input.dataset.feature] = Number(value);
        }
        const strategy = document.getElementById('strategy-select').value;
        const includeUncertainty = document.getElementById('uncertainty-toggle').checked;
        try {
          const response = await fetch(
            `/predict?strategy=${encodeURIComponent(strategy)}&all_strategies=true&uncertainty=${includeUncertainty}`,
            {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            },
          );
          const data = await response.json();
          const uncertaintyDiv = document.getElementById('uncertainty-result');
          uncertaintyDiv.innerHTML = '';
          if (response.ok && data.predictions) {
            document.getElementById('prediction-result').textContent =
              '预测已生成，详见下表。';
            const rows = Object.entries(data.predictions).map(
              ([name, values]) => [
                name,
                values.map((value) => Number(value).toFixed(2)).join(', '),
              ],
            );
            document.getElementById('prediction-table').innerHTML = createTable(
              ['策略', '预测值'],
              rows,
            );
            if (data.uncertainty) {
              const lower = data.uncertainty.lower.map((value) => Number(value).toFixed(2));
              const upper = data.uncertainty.upper.map((value) => Number(value).toFixed(2));
              const center = data.uncertainty.prediction.map((value) => Number(value).toFixed(2));
              uncertaintyDiv.innerHTML =
                `<div class="highlight-card">` +
                `<strong>区间 (${data.uncertainty.strategy}):</strong> ` +
                center
                  .map((value, idx) => `${value} [${lower[idx]}, ${upper[idx]}]`)
                  .join('， ') +
                '</div>';
            }
          } else if (response.ok && data.prediction) {
            document.getElementById('prediction-result').textContent =
              `预测结果 (${data.strategy}): ${data.prediction
                .map((value) => Number(value).toFixed(2))
                .join(', ')}`;
            document.getElementById('prediction-table').innerHTML = '';
            if (data.lower && data.upper) {
              const intervalText = data.lower
                .map((value, idx) =>
                  `${Number(data.prediction[idx]).toFixed(2)} ` +
                  `[${Number(value).toFixed(2)}, ${Number(data.upper[idx]).toFixed(2)}]`,
                )
                .join('， ');
              uncertaintyDiv.innerHTML =
                `<div class="highlight-card">预测区间：${intervalText}</div>`;
            }
          } else {
            throw new Error(data.error || '未知错误');
          }
        } catch (error) {
          document.getElementById('prediction-result').innerHTML =
            `<p class="error">预测失败：${error.message}</p>`;
          document.getElementById('prediction-table').innerHTML = '';
          document.getElementById('uncertainty-result').innerHTML = '';
        }
      }

      document
        .getElementById('predict-form')
        .addEventListener('submit', handlePredict);
      document.addEventListener('DOMContentLoaded', initDashboard);
    </script>
  </body>
</html>
